clc;clear all;close all;

%% BLOQUE DE CODIFICACIÓN DE FUENTE
image_name = 'walter.jpg';
x=double(imread(image_name));           
[r,c,d]=size(x);                          %Tamaño de la imagen
delta = 0.1;                            %Relación de compresión
figure;
imshow(image_name);
title('IMAGEN ENVIADA');

% SE COMPRIME LA IMAGEN USANDO LAS TRANSFORMADAS DE WAVELET DE HAAR
tic;
vector_a_enviar = zipImage(image_name,delta);  
disp("IMAGEN COMPRIMIDA USANDO LAS TRANSFORMADAS DE WAVELET DE HAAR");
toc

% EL VECTOR RECIBIDO LO PASAMOS A STRING
fuente = vector_a_enviar;
i = 1;
newFuente = "";
s = length(fuente);
while i<=s
    newFuente = newFuente + char(string(fuente(i)));
    newFuente = newFuente + " ";
    i=i+1;
end
fuente = char(newFuente);

% COMPRIMIMOS Y CODIFICAMOS A BINARIO EL VECTOR RECIBIDO CON LZW
tic;
ristraDeBitsComprimida = zipLzw(fuente);%%RISTRA DE BITS A ENVIAR
disp("ZIPLZW TERMINADO");
toc

%% BLOQUE CODIFICACION DE CANAL
tic
C = codCanal(ristraDeBitsComprimida);
disp("CODIFICACION DE CANAL TERMINADA");
toc

data = C;
figure(2);subplot(2,1,1);stem(data,'fill','r--','LineWidth',0.5);grid on;
title(['bits generated by the source = ',num2str(length(data))]);ylabel('Logic Level');
xlabel(['number of bits = ',num2str(length(data))]);

%% GRAFICAR LA SEÑAL DIGITAL EN TIEMPO DISCRETO
Nbits = length(data);	  % Número total de bits a transmitir
Tb = 1/(Nbits);             % Intervalo o periodo de bit
Rb = 1/Tb;                % Tasa de transmisión binaria (bits/s)
tb = (0:Tb:1-Tb)*10^0;     % Vector de tiempo de duración un segundo para graficar Rb

figure(2);subplot(2,1,2);stem(tb(1:100),data(1:100),'b--','fill','LineWidth',1.0);axis([0 Tb*100 0 1.1]);
xlabel('Time (s)');
ylabel('Logical Level');xlabel('Time (s)');
title([num2str(Nbits) ' bits generated by the source with bit period Tb = ',num2str(Tb*10^3), ' (ms) ']);grid on

%% BLOQUE DE MODULACION Y DEMODULACION
tic;
M = 16;                                             %Tamaño del alfabeto (símbolos digitales a Tx)
b = log2(M);                                        % Número de bits/símbolo banda base o pasabanda

Nbits = length(data);	                            % Número total de bits a transmitir
% GENERANDO LOS SIMBOLOS BANDA BASE
Nsymb = Nbits/b;                                    % Numero de símbolos digitales banda base a TX, debe ser un número entero

% Si Nsymb NO ES ENTERO, SE DEBE CONCATENAR LA SECUENCIA BINARIA Nbits
data_c = 0;                                         % Inicializando la variable
if mod(Nbits,b)==0;                             
   data_c = [data de2bi(0,b)];           
elseif mod(Nbits,b)~= 0;
   concat = zeros(1,b-mod(Nbits,b));                % Numero de ceros que se deben adicionar a los datos originales
   data_c = [data concat de2bi(b-mod(Nbits,b),b)];  % Datos originales concatenados con los ceros y la cantidad de ceros
end
Nbits_c = length(data_c);   % La nueva secuencia binaria con datos concatenados

% SE SEGMENTA LA NUEVA SECUENCIA BINARIA (número de símbolos o mensajes digitales banda base mi a transmitir)
Nsymb = Nbits_c/b;                                  % Numero de símbolos digitales
Ts = 1/Nsymb;                                       % Intervalo o periodo de símbolo banda base
Rs = 1/Ts;                                          % Tasa de transmisión de símbolos banda base (símbolos/s)

% CODIFICACIÓN GRAY PARA CADA UNO DE LOS SIMBOLOS DIGITALES mi
bits_symbol = zeros(b,Nsymb);
bits_symbol(:)= data_c;

%LISTA CADA SIMBOLO A ENVIAR Y SU VALOR EN DECIMAL
indice_symbol = bi2de(transpose(bits_symbol),'left-msb');       
A = 1;                                              % distancia de separación de los símbolos M-PAM

% Codificación Gray de los símbolos
[indices_pam,mapeo_pam] = bin2gray(indice_symbol,'pam',M);      

symbol_pam = transpose(indices_pam*2-(M-1));        % VALORES DE VOLTAJE ai

g = symbol_pam;                                     % Símbolos banda base a transmitir
disp("MODULACION PAM-16 TERMINADO");
toc


% PASAR LOS SIMBOLOS BANDA BASE POR EL CANAL AWGN (Solo adiciona ruido estocástico)

scatterplot(g,[],[],'r-*');grid on;    % Constelación de los símbolos banda base antes de entrar al canal
title('Transmit signal constellation');hold on
legend('Transmit signal');

% RELACIÓN SNR PARA EL CANAL AWGN
Es_N0_dB = [-2:2:20];        % Vector de relación señal a ruido para los símbolos values
Matriz = zeros(1,Nsymb);   % Matriz de Zeros

s = (1/sqrt(5))*g;         % normalization of energy of the baseband symbols, pulso conformador
n = 1/sqrt(2)*[randn(1,Nsymb) + j*randn(1,Nsymb)]; % AWGN; mean=0 dB
alpha = rand(1,length(Es_N0_dB));  % Attenuation factor

for ii = 1:length(Es_N0_dB)
%%  TRANSMISION
    y = s + 10^(-Es_N0_dB(ii)/20)*n;   % Transmited signal with only AWGN
    
    % y = s*alpha(ii) + 10^(-Es_N0_dB(ii)/20)*n;   % Transmited signal with AWGN and attenuation
    
%%  RECEPCION
    rx = real(y);                       % Rx signal and taking only the real part of de y
%%  DEMODULACION
    Matriz(find(rx< -14/sqrt(5))) = -15;
    Matriz(find(rx>= -14/sqrt(5) & rx<=-13/sqrt(5))) = -13;
    Matriz(find(rx< -12/sqrt(5) & rx>-13/sqrt(5))) = -13;
    Matriz(find(rx>= -12/sqrt(5) & rx<=-11/sqrt(5))) = -11;
    Matriz(find(rx< -10/sqrt(5) & rx>-11/sqrt(5))) = -11;
    Matriz(find(rx>= -10/sqrt(5) & rx<=-9/sqrt(5))) = -9;
    Matriz(find(rx< -8/sqrt(5) & rx>-9/sqrt(5))) = -9;
    Matriz(find(rx>= -8/sqrt(5) & rx<=-7/sqrt(5))) = -7;
    Matriz(find(rx< -6/sqrt(5) & rx>-7/sqrt(5))) = -7;
    Matriz(find(rx>= -6/sqrt(5) & rx<=-5/sqrt(5))) = -5;
    Matriz(find(rx< -4/sqrt(5) & rx>-5/sqrt(5))) = -5;
    Matriz(find(rx>= -4/sqrt(5) & rx<=-3/sqrt(5))) = -3;
    Matriz(find(rx< -2/sqrt(5) & rx>-3/sqrt(5))) = -3;
    Matriz(find(rx>= -2/sqrt(5) & rx<=-1/sqrt(5))) = -1;
    Matriz(find(rx< 0/sqrt(5) & rx>-1/sqrt(5))) = -1;
    Matriz(find(rx>= 0/sqrt(5) & rx<=1/sqrt(5))) = 1;
    Matriz(find(rx< 2/sqrt(5) & rx>1/sqrt(5))) = 1;
    Matriz(find(rx>= 2/sqrt(5) & rx<=3/sqrt(5))) = 3;
    Matriz(find(rx< 4/sqrt(5) & rx>3/sqrt(5))) = 3;
    Matriz(find(rx>= 4/sqrt(5) & rx<=5/sqrt(5))) = 5;
    Matriz(find(rx< 6/sqrt(5) & rx>5/sqrt(5))) = 5;
    Matriz(find(rx>= 6/sqrt(5) & rx<=7/sqrt(5))) = 7;
    Matriz(find(rx< 8/sqrt(5) & rx>7/sqrt(5))) = 7;
    Matriz(find(rx>= 8/sqrt(5) & rx<=9/sqrt(5))) = 9;
    Matriz(find(rx< 10/sqrt(5) & rx>9/sqrt(5))) = 9;
    Matriz(find(rx>= 10/sqrt(5) & rx<=11/sqrt(5))) = 11;
    Matriz(find(rx< 12/sqrt(5) & rx>11/sqrt(5))) = 11;
    Matriz(find(rx>= 12/sqrt(5) & rx<=13/sqrt(5))) = 13;
    Matriz(find(rx< 14/sqrt(5) & rx>13/sqrt(5))) = 13;
    Matriz(find(rx>= 14/sqrt(5))) = 15;
    nErr(ii) = size(find([g - Matriz]),2);     % couting the number of errors
end

%% GRAFICA PROBABILIDAD DE ERROR DE SIMBOLO VS RELACION SEÑAL A RUIDO
simBer = nErr/Nsymb;
figure;semilogy(Es_N0_dB,simBer,'mx-');axis([-3 20 10^-5 1]);grid on
legend('simulation');xlabel('Es/No, dB')
ylabel('Symbol Error Rate')
title('Symbol error Rate for 16-PAM modulation');

%% CONSTELACION DE LOS SIMBOLOS PASABANDA Tx Rx
h = scatterplot(rx*sqrt(5),[],[],'b.');grid on;hold on
scatterplot(g,[],[],'r*',h)
title('Received signal constellation');
legend('Received Symbols','Transmit Symbols');

%% DECODIFICACION DE LOS SIMBOLOS 16 PAM
tic;
symbolPamRestaured = Matriz;
indicesPamRestaured = transpose((symbolPamRestaured+(M-1))/2); 
[indice_symbolRestaured, mapeo_symbol] = gray2bin(indicesPamRestaured,'pam',M);
bits_symbolRestaured = de2bi(transpose(indice_symbolRestaured),'left-msb');
data_c_restaured = reshape(bits_symbolRestaured', 1, []);
bitsABorrar = bi2de(data_c_restaured(length(data_c_restaured)-b+1:length(data_c_restaured)));
data_restaured = data_c_restaured(1:length(data_c_restaured)-bitsABorrar-b);
C_restaured = data_restaured;
disp("DEMODULACION PAM16 TERMINADO")
toc

%% BLOQUE DECODIFICACION DE CANAL
tic
Mr = decodCanal(C_restaured);
disp("DECODIFICACION DE CANAL TERMINADA");
toc

%% BLOQUE DE DECODIFICACION DE FUENTE

% DESCOMPRIMIMOS LA RISTRA DE BITS RECIBIDA DESDE EL BLOQUE CODIFICACION DE
% CANAL.
tic;
vector_reconstruido = unzipLzw(Mr);
disp("UNZIPLZW TERMINADO");
toc

% RECONSTRUIMOS LA IMAGEN COMPRIMIDA CON LAS TRANSFORMADAS DE WAVELET DE
% HAAR.
vector_reconstruido = str2num(vector_reconstruido);
tic;
imagenDescomprimida = unzipImage(vector_reconstruido,r,c);
disp("SE RECONSTRUYO LA IMAGEN COMPRIMIDA CON LAS TRANSFORMADAS DE WAVELET DE HAAR")
%% IMAGEN RECIBIDA
toc

figure;
imshow(imagenDescomprimida/255);        % Muestra la imagen descomprimida
% Below value is a measure of compression ratio, not the exact ratio
% compression_ratio=n1/n2
title('IMAGEN RECIBIDA');